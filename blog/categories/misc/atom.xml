<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: misc | Emacs Redux]]></title>
  <link href="http://emacsredux.com/blog/categories/misc/atom.xml" rel="self"/>
  <link href="http://emacsredux.com/"/>
  <updated>2016-01-31T09:10:32+02:00</updated>
  <id>http://emacsredux.com/</id>
  <author>
    <name><![CDATA[Bozhidar Batsov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Use Tab to Indent or Complete]]></title>
    <link href="http://emacsredux.com/blog/2016/01/31/use-tab-to-indent-or-complete/"/>
    <updated>2016-01-31T09:02:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/31/use-tab-to-indent-or-complete</id>
    <content type="html"><![CDATA[<p>By default in Emacs the <code>Tab</code> key does only indentation. If some major
mode provides completion of some form, you normally have to trigger it
with <code>M-Tab</code>. In most window managers, however, this keybinding is used to
switch between open windows, which makes it a bit hard to use out of the box.</p>

<p>There's a simple trick to augment the default <code>Tab</code> behavior. Just put
this in your Emacs config:</p>

<p><code>cl
(setq tab-always-indent â€˜complete)
</code></p>

<p>Now, when you press <code>Tab</code> one time it will indent and if you press it
again you'll get completion candidates. If the indentation at point is
already correct you'll get the completion candidates right away. As an
added bonus - you don't really need <code>M-Tab</code> anymore.</p>

<p>Simple and neat! One really has to wonder why this isn't the default
behavior.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Personal Emacs Configuration]]></title>
    <link href="http://emacsredux.com/blog/2016/01/30/my-personal-emacs-configuration/"/>
    <updated>2016-01-30T12:31:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/30/my-personal-emacs-configuration</id>
    <content type="html"><![CDATA[<p>From time to time people ask me about my personal Emacs
configuration. Other just assume that I use
<a href="https://github.com/bbatsov/prelude">Prelude</a>. For a very long time my
personal configuration was pretty similar to Prelude - in a way it was
a staging ground for things to go into Prelude eventually (although
changes would travel both ways when Prelude users suggest some cool
things).</p>

<p>Recently I've decided that in the future I want to do a few things with Prelude:</p>

<ul>
<li>extract as much functionality from it as possible into reusable
packages (e.g. <a href="https://github.com/bbatsov/super-save">super-save</a>
and <a href="https://github.com/bbatsov/crux">crux</a>)</li>
<li>adopt there <a href="https://github.com/jwiegley/use-package">use-package</a></li>
<li>improve the support for Windows (because now I have Windows computer)</li>
</ul>


<p>As part of these efforts I reworked my personal config into something
pretty simple (it's a single <code>init.el</code> file) and I've started
experimenting with ideas for the future. Stay tuned for the results!</p>

<p>The config is available
<a href="https://github.com/bbatsov/emacs.d">here</a>. Perhaps some of you will
find something useful there.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remap Return to Control in GNU/Linux]]></title>
    <link href="http://emacsredux.com/blog/2016/01/30/remap-return-to-control-in-gnu-slash-linux/"/>
    <updated>2016-01-30T11:48:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/30/remap-return-to-control-in-gnu-slash-linux</id>
    <content type="html"><![CDATA[<p>A long time ago I wrote about
<a href="http://emacsredux.com/blog/2013/11/12/a-crazy-productivity-boost-remap-return-to-control/">remapping Return to Control in OS X</a>.
This was the best productivity boost for my Emacs experience ever!</p>

<p>Recently I've bought a Windows ultrabook (wanted something as light as
MacBook Air, but more powerful and versatile) and I'm doing most of my
work there in a Xubuntu VM. The first thing I did while setting up Xubuntu
was to figure out how to do the aforementioned remapping.</p>

<p>In my original post some people suggested the tool
<a href="https://github.com/alols/xcape">xcape</a>, so I took a look at it.  The
tool can certainly use some documentation improvements (and pre-built
packages), but it gets the job done. After you've installed it you
just need to add the following to your login shell's init file
(e.g. <code>.bash_profile</code>) and you're in business:</p>

<p>```
xmodmap -e "remove Control = Control_R"
xmodmap -e "keycode 0x69 = Return"
xmodmap -e "keycode 0x24 = Control_R"
xmodmap -e "add Control = Control_R"</p>

<p>xcape -t 10000 -e "Control_R=Return"
```</p>

<p>Obviously the first time around you should source <code>.bash_profile</code>
after updating it:</p>

<p><code>
$ . .bash_profile
</code></p>

<p>This is definitely a lot more work than just clicking in the GUI of
the wonderful <a href="https://pqrs.org/osx/karabiner/">Karabiner</a>, but it yields
the desired results and that's what's important at the end of the day.</p>

<p>Now if only there was a way to achieve the same result in Windows...</p>

<p>P.S. <code>vim</code> users will love <code>xcape</code>. Its default behaviour is to
generate the <code>Escape</code> key when <code>Left Control</code> is pressed and released on
its own.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crux]]></title>
    <link href="http://emacsredux.com/blog/2016/01/30/crux/"/>
    <updated>2016-01-30T11:37:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/30/crux</id>
    <content type="html"><![CDATA[<p>I'd often blog about some useful utility functions here. Pretty much
all of them get included in
<a href="https://github.com/bbatsov/prelude">Emacs Prelude</a>, but I've decided I can do one better and extract those of
them which are most useful/universal into a separate package.</p>

<p>This package is <a href="https://github.com/bbatsov/crux">crux</a> - a
<strong>C</strong>ollection of <strong>R</strong>idiculously <strong>U</strong>seful e<strong>X</strong>tensions for
Emacs.</p>

<p>You can install it from MELPA and MELPA Stable. Once this is done you
just have to pick keybindings for the commands shipped with
<code>crux</code>. I've suggested some keybindings
<a href="https://github.com/bbatsov/crux#keybindings">here</a>. And here's a
small configuration snippet showing how to actually bind keys to some
of <code>crux</code>'s commands:</p>

<p><code>cl
(global-set-key [remap move-beginning-of-line] #'crux-move-beginning-of-line)
(global-set-key (kbd "C-c o") #'crux-open-with)
(global-set-key [(shift return)] #'crux-smart-open-line)
(global-set-key (kbd "s-r") #'crux-recentf-ido-find-file)
(global-set-key (kbd "C-&lt;backspace&gt;" #'crux-kill-line-backwards))
(global-set-key [remap kill-whole-line] #'crux-kill-whole-line)
</code></p>

<p><code>crux</code> also ships with some handy advises that can enhance the operation of existing commands.</p>

<p>For instance - you can use <code>crux-with-region-or-buffer</code> to make a
command acting normally on a region to operate on the entire buffer in
the absense of a region. Here are a few examples you can stuff in your
config:</p>

<p><code>cl
(crux-with-region-or-buffer indent-region)
(crux-with-region-or-buffer untabify)
</code></p>

<p>So, this is <code>crux</code> for you - simple and neat! I'd love it if you
contributed more useful commands to it, so we can make it even more
versatile!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[super-save]]></title>
    <link href="http://emacsredux.com/blog/2016/01/30/super-save/"/>
    <updated>2016-01-30T11:26:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/30/super-save</id>
    <content type="html"><![CDATA[<p>A while back I wrote
<a href="http://batsov.com/articles/2012/03/08/emacs-tip-number-5-save-buffers-automatically-on-buffer-or-window-switch/">an article on saving buffers when they lose focus</a>.</p>

<p>Recently I've packaged (an improved version of) this functionality
into a tiny global minor mode called
<a href="https://github.com/bbatsov/super-save">super-save</a>.</p>

<p>The package is available on MELPA and MELPA Stable and enabling it is trivial:</p>

<p><code>cl
(super-save-mode +1)
</code></p>

<p>If you're like me and don't care about the backups created by the
built-in <code>auto-save-mode</code>, you can disable it aftewards:</p>

<p><code>cl
(setq auto-save-default nil)
</code></p>

<p>I wouldn't really recommend doing this until I've added a bit of
functionality to save the current buffer when you're not typing, but
the option obviously exists. I've been using Emacs for over 10 years
now and I've never needed the auto-created backups - I'm either very
lucky or this is less useful than it's supposed to be.</p>
]]></content>
  </entry>
  
</feed>
