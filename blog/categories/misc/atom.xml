<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: misc | Emacs Redux]]></title>
  <link href="http://emacsredux.com/blog/categories/misc/atom.xml" rel="self"/>
  <link href="http://emacsredux.com/"/>
  <updated>2017-12-31T00:02:49+02:00</updated>
  <id>http://emacsredux.com/</id>
  <author>
    <name><![CDATA[Bozhidar Batsov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Look up the keybindings for some command]]></title>
    <link href="http://emacsredux.com/blog/2016/02/14/look-up-the-keybindings-for-some-command/"/>
    <updated>2016-02-14T18:10:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/02/14/look-up-the-keybindings-for-some-command</id>
    <content type="html"><![CDATA[<p>If you know the name of some command, but you've forgotten its
keybinding(s) there are 3 common options to look the keybinding(s) up.</p>

<ul>
<li><code>C-h f command-name</code></li>
</ul>


<p>This will display some information about the command in question in a help buffer.
Important bits of this information include where is the command defined, what are its
keybindingings if any, and its documentation.</p>

<ul>
<li><code>C-h w command-name</code></li>
</ul>


<p>This will display the keybindings of the command in the minibuffer. If you're interested only
in the keybindings you should prefer this option over <code>C-h f</code>.</p>

<ul>
<li><code>M-x command-name</code></li>
</ul>


<p>After you invoke some command using <code>M-x</code> you'll see a suggestion to use
its keybinding instead in the minibuffer.</p>

<p>That's all for now, folks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Disable annoying audio notifications]]></title>
    <link href="http://emacsredux.com/blog/2016/02/14/disable-annoying-audio-notifications/"/>
    <updated>2016-02-14T12:09:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/02/14/disable-annoying-audio-notifications</id>
    <content type="html"><![CDATA[<p>By default Emacs has some pretty annoying audio notifications for
certain events (e.g. trying to move past the end of a buffer). You've
got two options to get rid of them. Option 1 is to replace them with visual
notifications (the Emacs frame will flash):</p>

<p><code>cl
(setq visible-bell t)
</code></p>

<p>This doesn't work well on OS X and is just as annoying (if not even
more), so I'd suggest going with option 2 instead - disable those
notifications completely:</p>

<p><code>cl
(setq ring-bell-function 'ignore)
</code></p>

<p>At last - some peace and quiet!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Tab to Indent or Complete]]></title>
    <link href="http://emacsredux.com/blog/2016/01/31/use-tab-to-indent-or-complete/"/>
    <updated>2016-01-31T09:02:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/31/use-tab-to-indent-or-complete</id>
    <content type="html"><![CDATA[<p>By default in Emacs the <code>Tab</code> key does only indentation. If some major
mode provides completion of some form, you normally have to trigger it
with <code>M-Tab</code>. In most window managers, however, this keybinding is used to
switch between open windows, which makes it a bit hard to use out of the box.</p>

<p>There's a simple trick to augment the default <code>Tab</code> behavior. Just put
this in your Emacs config:</p>

<p><code>cl
(setq tab-always-indent â€˜complete)
</code></p>

<p>Now, when you press <code>Tab</code> one time it will indent and if you press it
again you'll get completion candidates. If the indentation at point is
already correct you'll get the completion candidates right away. As an
added bonus - you don't really need <code>M-Tab</code> anymore.</p>

<p>Simple and neat! One really has to wonder why this isn't the default
behavior.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Personal Emacs Configuration]]></title>
    <link href="http://emacsredux.com/blog/2016/01/30/my-personal-emacs-configuration/"/>
    <updated>2016-01-30T12:31:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/30/my-personal-emacs-configuration</id>
    <content type="html"><![CDATA[<p>From time to time people ask me about my personal Emacs
configuration. Other just assume that I use
<a href="https://github.com/bbatsov/prelude">Prelude</a>. For a very long time my
personal configuration was pretty similar to Prelude - in a way it was
a staging ground for things to go into Prelude eventually (although
changes would travel both ways when Prelude users suggest some cool
things).</p>

<p>Recently I've decided that in the future I want to do a few things with Prelude:</p>

<ul>
<li>extract as much functionality from it as possible into reusable
packages (e.g. <a href="https://github.com/bbatsov/super-save">super-save</a>
and <a href="https://github.com/bbatsov/crux">crux</a>)</li>
<li>adopt there <a href="https://github.com/jwiegley/use-package">use-package</a></li>
<li>improve the support for Windows (because now I have Windows computer)</li>
</ul>


<p>As part of these efforts I reworked my personal config into something
pretty simple (it's a single <code>init.el</code> file) and I've started
experimenting with ideas for the future. Stay tuned for the results!</p>

<p>The config is available
<a href="https://github.com/bbatsov/emacs.d">here</a>. Perhaps some of you will
find something useful there.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remap Return to Control in GNU/Linux]]></title>
    <link href="http://emacsredux.com/blog/2016/01/30/remap-return-to-control-in-gnu-slash-linux/"/>
    <updated>2016-01-30T11:48:00+02:00</updated>
    <id>http://emacsredux.com/blog/2016/01/30/remap-return-to-control-in-gnu-slash-linux</id>
    <content type="html"><![CDATA[<p>A long time ago I wrote about
<a href="http://emacsredux.com/blog/2013/11/12/a-crazy-productivity-boost-remap-return-to-control/">remapping Return to Control in OS X</a>.
This was the best productivity boost for my Emacs experience ever!</p>

<p>Recently I've bought a Windows ultrabook (wanted something as light as
MacBook Air, but more powerful and versatile) and I'm doing most of my
work there in a Xubuntu VM. The first thing I did while setting up Xubuntu
was to figure out how to do the aforementioned remapping.</p>

<p>In my original post some people suggested the tool
<a href="https://github.com/alols/xcape">xcape</a>, so I took a look at it.  The
tool can certainly use some documentation improvements (and pre-built
packages), but it gets the job done. After you've installed it you
just need to add the following to your login shell's init file
(e.g. <code>.bash_profile</code>) and you're in business:</p>

<p>```
xmodmap -e "remove Control = Control_R"
xmodmap -e "keycode 0x69 = Return"
xmodmap -e "keycode 0x24 = Control_R"
xmodmap -e "add Control = Control_R"</p>

<p>xcape -t 10000 -e "Control_R=Return"
```</p>

<p>Obviously the first time around you should source <code>.bash_profile</code>
after updating it:</p>

<p><code>
$ . .bash_profile
</code></p>

<p>This is definitely a lot more work than just clicking in the GUI of
the wonderful <a href="https://pqrs.org/osx/karabiner/">Karabiner</a>, but it yields
the desired results and that's what's important at the end of the day.</p>

<p>Now if only there was a way to achieve the same result in Windows...</p>

<p>P.S. <code>vim</code> users will love <code>xcape</code>. Its default behaviour is to
generate the <code>Escape</code> key when <code>Left Control</code> is pressed and released on
its own.</p>
]]></content>
  </entry>
  
</feed>
